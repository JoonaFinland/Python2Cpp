# python script to create the cc files for Kerasify
import argparse
from kerasify import export_model
from keras.models import load_model
import os

def tensorflow_shutup():
    """
    Make Tensorflow less verbose
    """
    try:
        # noinspection PyPackageRequirements
        from tensorflow import logging
        logging.set_verbosity(logging.ERROR)
        os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

        # Monkey patching deprecation utils to shut it up! Maybe good idea to disable this once after upgrade
        # noinspection PyUnusedLocal
        def deprecated(date, instructions, warn_once=True):
            def deprecated_wrapper(func):
                return func
            return deprecated_wrapper

        from tensorflow.python.util import deprecation
        deprecation.deprecated = deprecated

    except ImportError:
        pass
		
def main(args):
	tensorflow_shutup()
	model = load_model(args.model)
	export_model(model, "tmp/"+args.name+".temp")	
	curdir = os.path.dirname(os.path.abspath(__file__))
	dirs = curdir.split("\\")
	curdir = ("/").join(dirs[0:-1])
	with open("source/"+args.name+".cpp", "w") as f:
		f.write('''// Auto-generated by keraport.py, do not modify
#include <iostream>
#include <fstream>
#include <math.h>
#include <string.h>
#include "mex.hpp"
#include "mexAdapter.hpp"
#include "keras_model.hpp"
#include <memory>

class MexFunction : public matlab::mex::Function {
	matlab::data::ArrayFactory factory;
	std::shared_ptr<matlab::engine::MATLABEngine> matlabPtr = getEngine();
	std::ostringstream stream;
	public: 
	void operator() (matlab::mex::ArgumentList outputs, matlab::mex::ArgumentList inputs) {
		//checkArguments(outputs, inputs);
		bool bypass;
		if (inputs[inputs.size() - 1].getType() == matlab::data::ArrayType::LOGICAL) {
			bypass = inputs[inputs.size() - 1][0];
		} else {
			bypass = false;
		}
		if (bypass == true) {
			mexPrintf("**Ignoring errors for dimensions**");
		}
		// implementation for multiple predictions
		for (int i = 0; i < inputs.size(); i++) {
			if (inputs[i].getType() == matlab::data::ArrayType::DOUBLE) {
				matlab::data::TypedArray<double> doubleArray = std::move(inputs[i]);
				std::vector<float> vectorFloats;
				for (auto& elem : doubleArray) {
					vectorFloats.push_back((float)elem);
				}
				std::vector<float> VecOut = predict(vectorFloats, bypass);
				std::vector<double> doubleVec;
				for (auto elem : VecOut) {
					doubleVec.push_back((double)elem);
				}
				matlab::data::TypedArray<double> doubleOut = factory.createArray({ 1,doubleVec.size() }, doubleVec.begin(), doubleVec.end());
				outputs[i] = std::move(doubleOut);
			}
			else if (bypass==true && i == inputs.size()-1) {
				//do nothing
			}
			else {
				mexError("Input must be a double array");
			}
		}
	}
	void mexPrintf(std::string stream) {
        // Pass stream content to MATLAB fprintf function
        matlabPtr->feval(u"fprintf", 0,
            std::vector<matlab::data::Array>({ factory.createScalar(stream) }));
    }
	void mexError(std::string stream) {
		// Pass stream content to MATLAB fprintf function
		matlabPtr->feval(u"error", 0,
			std::vector<matlab::data::Array>({ factory.createScalar(stream) }));
	}
	std::vector<float> predict(std::vector<float> input, int bypass) {
		KerasModel model;
		model.LoadModel("%s/tmp/%s.temp");
		Tensor in(input.size());
		in.data_ = input;
		Tensor out;
		//test if dimensions match
		//KerasLayer* layer = model.layers_[0];
		std::string str = model.firstlayer_->Check(&in);
		if (str != "true" && bypass == false) {
			mexError(str);
		}
		model.Apply(&in, &out);
		return out.data_;
	}
};''' % (curdir,args.output))

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Create cc and model file')
	parser.add_argument("model")
	parser.add_argument("name")
	parser.add_argument("output")
	exit(main(parser.parse_args()))